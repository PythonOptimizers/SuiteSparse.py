from __future__ import print_function

from suitesparse.cholmod.cholmod_solver_base_@index@_@type@ cimport CHOLMODSolverBase_@index@_@type@
from suitesparse.common_types.suitesparse_types cimport *
{% if type in complex_list %}
from suitesparse.common_types.suitesparse_generic_types cimport split_array_complex_values_kernel_@index@_@type@, join_array_complex_values_kernel_@index@_@type@
{% endif %}
from suitesparse.cholmod.cholmod_common import CHOLMOD_SYS_DICT

from cysparse.sparse.s_mat cimport PySparseMatrix_Check, PyLLSparseMatrix_Check, PyCSCSparseMatrix_Check, PyCSRSparseMatrix_Check
from cysparse.sparse.csc_mat_matrices.csc_mat_@index@_@type@ cimport CSCSparseMatrix_@index@_@type@, MakeCSCSparseMatrix_@index@_@type@
from cysparse.sparse.csr_mat_matrices.csr_mat_@index@_@type@ cimport CSRSparseMatrix_@index@_@type@, MakeCSRSparseMatrix_@index@_@type@

from cpython.mem cimport PyMem_Malloc, PyMem_Realloc, PyMem_Free

import numpy as np
cimport numpy as cnp

cnp.import_array()

import time

cdef extern from "cholmod.h":
    # we only use REAL and ZOMPLEX
    cdef enum:
        CHOLMOD_PATTERN  	# pattern only, no numerical values
        CHOLMOD_REAL		# a real matrix
        CHOLMOD_COMPLEX     # a complex matrix (ANSI C99 compatible)
        CHOLMOD_ZOMPLEX     # a complex matrix (MATLAB compatible)

    # itype: we only use INT and LONG
    cdef enum:
        CHOLMOD_INT         # all integer arrays are int
        CHOLMOD_INTLONG     # most are int, some are SuiteSparse_long
        CHOLMOD_LONG        # all integer arrays are SuiteSparse_long

    # dtype: float or double
    # dtype: float or double
    cdef enum:
        CHOLMOD_DOUBLE      # all numerical values are double
        CHOLMOD_SINGLE



    int @index|cysparse_real_type_to_cholmod_prefix@_start(cholmod_common *Common)
    int @index|cysparse_real_type_to_cholmod_prefix@_finish(cholmod_common *Common)

    int @index|cysparse_real_type_to_cholmod_prefix@_defaults(cholmod_common *Common)

    # Common struct
    int @index|cysparse_real_type_to_cholmod_prefix@_check_common(cholmod_common *Common)
    int @index|cysparse_real_type_to_cholmod_prefix@_print_common(const char *name, cholmod_common *Common)

    # Sparse struct
    int @index|cysparse_real_type_to_cholmod_prefix@_check_sparse(cholmod_sparse *A, cholmod_common *Common)
    int @index|cysparse_real_type_to_cholmod_prefix@_print_sparse(cholmod_sparse *A, const char *name, cholmod_common *Common)
    int @index|cysparse_real_type_to_cholmod_prefix@_free_sparse(cholmod_sparse **A, cholmod_common *Common)

    # Dense struct
    int @index|cysparse_real_type_to_cholmod_prefix@_free_dense(cholmod_dense **X, cholmod_common *Common)

    # Factor struct
    int @index|cysparse_real_type_to_cholmod_prefix@_check_factor(cholmod_factor *L, cholmod_common *Common)
    int @index|cysparse_real_type_to_cholmod_prefix@_print_factor(cholmod_factor *L, const char *name, cholmod_common *Common)
    #int @index|cysparse_real_type_to_cholmod_prefix@_free_factor()
    # factor_to_sparse

    # Memory management
    void * @index|cysparse_real_type_to_cholmod_prefix@_free(size_t n, size_t size,	void *p,  cholmod_common *Common)



########################################################################################################################
# CHOLMOD HELPERS
########################################################################################################################
##################################################################
# FROM CSCSparseMatrix -> cholmod_sparse
##################################################################
# Populating a sparse matrix in CHOLMOD is done in two steps:
# - first (populate1), we give the common attributes and
# - second (populate2), we split the values array in two if needed (complex case) and give the values (real or complex).

cdef populate1_cholmod_sparse_struct_with_CSCSparseMatrix(cholmod_sparse * sparse_struct, CSCSparseMatrix_@index@_@type@ csc_mat, bint no_copy=True):
    """
    Populate a CHOLMO C struct ``cholmod_sparse`` with the content of a :class:`CSCSparseMatrix_@index@_@type@` matrix.

    First part: common attributes for both real and complex matrices.

    Note:
        We only use the ``cholmod_sparse`` **packed** and **sorted** version.
    """
    assert no_copy, "The version with copy is not implemented yet..."

    assert(csc_mat.are_row_indices_sorted()), "We only use CSC matrices with internal row indices sorted. The non sorted version is not implemented yet."

    sparse_struct.nrow = csc_mat.nrow
    sparse_struct.ncol = csc_mat.ncol
    sparse_struct.nzmax = csc_mat.nnz

    sparse_struct.p = csc_mat.ind
    sparse_struct.i = csc_mat.row

    # TODO: change this when we'll accept symmetric matrices **without** symmetric storage scheme
    if csc_mat.is_symmetric:
        sparse_struct.stype = -1
    else:
        sparse_struct.stype = 0

    # itype: can be CHOLMOD_INT or CHOLMOD_LONG: we don't use the mixed version CHOLMOD_INTLONG
{% if index in ['INT32_t'] %}
    sparse_struct.itype = CHOLMOD_INT
{% elif index in ['INT64_t'] %}
    sparse_struct.itype = CHOLMOD_LONG
{% else %}
YOU HAVE TO CAST YOUR INDEX TYPE HERE
{% endif %}

    sparse_struct.sorted = 1                                 # TRUE if columns are sorted, FALSE otherwise
    sparse_struct.packed = 1                                 # We use the packed CSC version: **no** need to construct
                                                             # the nz (array with number of non zeros by column)


{% if type in complex_list %}
cdef populate2_cholmod_sparse_struct_with_CSCSparseMatrix(cholmod_sparse * sparse_struct,
                                                              CSCSparseMatrix_@index@_@type@ csc_mat,
                                                              @type|cysparse_real_type_from_real_cysparse_complex_type@ * csc_mat_rval,
                                                              @type|cysparse_real_type_from_real_cysparse_complex_type@ * csc_mat_ival,
                                                              bint no_copy=True):
    """
    Populate a CHOLMO C struct ``cholmod_sparse`` with the content of a :class:`CSCSparseMatrix_@index@_@type@` matrix.

    Second part: Non common attributes for complex matrices.

    Note:
        We only use the ``cholmod_sparse`` **packed** version.
    """
    assert no_copy, "The version with copy is not implemented yet..."


    sparse_struct.x = csc_mat_rval
    sparse_struct.z = csc_mat_ival

    sparse_struct.xtype = CHOLMOD_ZOMPLEX                    # CHOLMOD_PATTERN, _REAL, _COMPLEX, or _ZOMPLEX
    sparse_struct.dtype = @type|cysparse_real_type_to_cholmod_type@


{% else %}
cdef populate2_cholmod_sparse_struct_with_CSCSparseMatrix(cholmod_sparse * sparse_struct, CSCSparseMatrix_@index@_@type@ csc_mat, bint no_copy=True):
    """
    Populate a CHOLMO C struct ``cholmod_sparse`` with the content of a :class:`CSCSparseMatrix_@index@_@type@` matrix.

    Second part: Non common attributes for complex matrices.


    """
    assert no_copy, "The version with copy is not implemented yet..."

    sparse_struct.x = csc_mat.val

    sparse_struct.xtype = CHOLMOD_REAL                    # CHOLMOD_PATTERN, _REAL, _COMPLEX, or _ZOMPLEX
    sparse_struct.dtype = @type|cysparse_real_type_to_cholmod_type@

{% endif %}

##################################################################
# FROM cholmod_sparse -> CSCSparseMatrix
##################################################################
cdef CSCSparseMatrix_@index@_@type@ cholmod_sparse_to_CSCSparseMatrix_@index@_@type@(cholmod_sparse * sparse_struct, bint no_copy=False):
    """
    Convert a ``cholmod`` sparse struct to a :class:`CSCSparseMatrix_@index@_@type@`.

    """
    # TODO: generalize to any cholmod sparse structure, with or without copy
    # TODO: generalize to complex case
    # TODO: remove asserts
    assert sparse_struct.sorted == 1, "We only accept cholmod_sparse matrices with sorted indices"
    assert sparse_struct.packed == 1, "We only accept cholmod_sparse matrices with packed indices"
{% if type in complex_list %}
    assert sparse_struct.xtype == CHOLMOD_ZOMPLEX, "We only accept cholmod_sparse matrices with zomplex"
{% else %}

{% endif %}

    cdef:
        CSCSparseMatrix_@index@_@type@ csc_mat
        @index@ nrow
        @index@ ncol
        @index@ nnz
        bint store_symmetric = False

        # internal arrays of the CSC matrix
        @index@ * ind
        @index@ * row

        # internal arrays of the cholmod sparse matrix
        @index@ * ind_cholmod
        @index@ * row_cholmod
{% if type in complex_list %}
        # internal arrays for the CSC matrix
        @type|cysparse_real_type_from_real_cysparse_complex_type@ * valx
        @type|cysparse_real_type_from_real_cysparse_complex_type@ * valz

        @type@ * val_complex

        # internal arrays for the cholmod sparse matrix
        @type|cysparse_real_type_from_real_cysparse_complex_type@ * valx_cholmod
        @type|cysparse_real_type_from_real_cysparse_complex_type@ * valz_cholmod

{% else %}
        # internal array for the CSC matrix
        @type@ * val

        # internal array for the cholmod sparse matrix
        @type@ * val_cholmod
{% endif %}

        @index@ j, k

    nrow = sparse_struct.nrow
    ncol = sparse_struct.ncol
    nnz = sparse_struct.nzmax

    if sparse_struct.stype == 0:
        store_symmetric = False
    elif sparse_struct.stype < 0:
        store_symmetric == True
    else:
        raise NotImplementedError('We do not accept cholmod square symmetric sparse matrix with upper triangular part filled in.')

    ##################################### NO COPY ######################################################################
    if no_copy:
        ind = <@index@ *> sparse_struct.p
        row = <@index@ *> sparse_struct.i
{% if type in complex_list %}
        valx = <@type|cysparse_real_type_from_real_cysparse_complex_type@ *> sparse_struct.x
        valz = <@type|cysparse_real_type_from_real_cysparse_complex_type@ *> sparse_struct.z
{% else %}
        val = <@type@ *> sparse_struct.x
{% endif %}
    ##################################### WITH COPY ####################################################################
    else:   # we do a copy

        ind_cholmod = <@index@ * > sparse_struct.p
        row_cholmod = <@index@ * > sparse_struct.i

        ind = <@index@ *> PyMem_Malloc((ncol + 1) * sizeof(@index@))

        if not ind:
            raise MemoryError()

        row = <@index@ *> PyMem_Malloc(nnz * sizeof(@index@))

        if not row:
            PyMem_Free(ind)
            PyMem_Free(row)

            raise MemoryError()


        for j from 0 <= j <= ncol:
            ind[j] = ind_cholmod[j]

        for k from 0 <= k < nnz:
            row[k] = row_cholmod[k]

{% if type in complex_list %}

        valx_cholmod = <@type|cysparse_real_type_from_real_cysparse_complex_type@ *> sparse_struct.x
        valz_cholmod = <@type|cysparse_real_type_from_real_cysparse_complex_type@ *> sparse_struct.z

        valx = <@type|cysparse_real_type_from_real_cysparse_complex_type@ *> PyMem_Malloc(nnz * sizeof(@type|cysparse_real_type_from_real_cysparse_complex_type@))

        if not valx:
            PyMem_Free(ind)
            PyMem_Free(row)
            PyMem_Free(valx)

            raise MemoryError()

        valz = <@type|cysparse_real_type_from_real_cysparse_complex_type@ *> PyMem_Malloc(nnz * sizeof(@type|cysparse_real_type_from_real_cysparse_complex_type@))

        if not valz:
            PyMem_Free(ind)
            PyMem_Free(row)
            PyMem_Free(valx)
            PyMem_Free(valz)

            raise MemoryError()

        for k from 0 <= k < nnz:
            valx[k] = valx_cholmod[k]
            valz[k] = valz_cholmod[k]
{% else %}
        val_cholmod = <@type@ * > sparse_struct.x

        val = <@type@ *> PyMem_Malloc(nnz * sizeof(@type@))

        if not val:
            PyMem_Free(ind)
            PyMem_Free(row)
            PyMem_Free(val)

            raise MemoryError()

        for k from 0 <= k < nnz:
            val[k] = val_cholmod[k]
{% endif %}

{% if type in complex_list %}
    raise NotImplementedError('Complex case not implemented yet...')
{% else %}
    csc_mat = MakeCSCSparseMatrix_@index@_@type@(nrow=nrow, ncol=ncol, nnz=nnz, ind=ind, row=row, val=val, store_symmetric=store_symmetric, store_zero=False)
{% endif %}

    return csc_mat


cdef class CHOLMODCysparseSolver_@index@_@type@(CHOLMODSolverBase_@index@_@type@):
    ####################################################################################################################
    # INIT
    ####################################################################################################################
    def __cinit__(self, A, **kwargs):
        assert PySparseMatrix_Check(A), "Matrix A is not recognized as a CySparse sparse matrix"

        self.nrow = A.nrow
        self.ncol = A.ncol

        # test if we can use CHOLMOD
        assert self.nrow == self.ncol, "Only square matrices are handled in CHOLMOD"
        # TODO: change this. This assumption is too strong
        assert self.A.store_symmetric, "Only symmetric matrices (using the symmetric storage scheme) are handled in CHOLMOD"

        self.nnz = self.A.nnz

        self.__matrix_transform_time = 0.0

        start_time = time.clock()

        if PyLLSparseMatrix_Check(self.__A):
            # transfrom matrix into CSC
            self.csc_mat = self.__A.to_csc()

        elif PyCSCSparseMatrix_Check(self.__A):
            self.csc_mat = self.__A
        elif PyCSRSparseMatrix_Check(self.__A):
            # transfrom matrix into CSC
            self.csc_mat = self.__A.to_csc()
        else:
            matrix_type = "unknown"
            try:
                matrix_type = self.__A.base_type_str
            except:
                matrix_type = type(self.__A)

            raise NotImplementedError("CySparse matrix type '%s' not recognized" % matrix_type)

        # We don't allow internal copies of CSC C arrays
        self.__no_copy = True

        # transform CSC mat into CHOLMOD sparse_struct
        # common attributes for real and complex matrices
        populate1_cholmod_sparse_struct_with_CSCSparseMatrix(self.sparse_struct, self.csc_mat, no_copy=self.__no_copy)
{% if type in complex_list %}

        cdef:
            @type|cysparse_real_type_from_real_cysparse_complex_type@ * rval
            @type|cysparse_real_type_from_real_cysparse_complex_type@ * ival

        rval = <@type|cysparse_real_type_from_real_cysparse_complex_type@ *> PyMem_Malloc(self.nnz * sizeof(@type|cysparse_real_type_from_real_cysparse_complex_type@))
        if not rval:
            raise MemoryError()
        self.csc_rval = rval

        ival = <@type|cysparse_real_type_from_real_cysparse_complex_type@ *> PyMem_Malloc(self.nnz * sizeof(@type|cysparse_real_type_from_real_cysparse_complex_type@))
        if not ival:
            PyMem_Free(rval)
            raise MemoryError()
        self.csc_ival = ival

        # split array of complex values into two real value arrays
        split_array_complex_values_kernel_@index@_@type@(self.csc_mat.val, self.nnz,
                                                     rval, self.nnz,
                                                     ival, self.nnz)

        populate2_cholmod_sparse_struct_with_CSCSparseMatrix(self.sparse_struct, self.csc_mat, rval, ival, no_copy=self.__no_copy)
{% else %}
        populate2_cholmod_sparse_struct_with_CSCSparseMatrix(self.sparse_struct, self.csc_mat, no_copy=self.__no_copy)
{% endif %}


        self.__matrix_transform_time += (time.clock() - start_time)

        # this is for the main stats from the Solver class
        self.__specialized_solver_time += self.__matrix_transform_time

        # Internal test:
        # common attributes
        assert self.check_common_attributes(), "Internal problem: Common attributes are wrong"
        # Control the matrix is fine
        assert self.check_matrix(), "Internal problem: matrix has some problems"

    ####################################################################################################################
    # FREE MEMORY
    ####################################################################################################################
    def __dealloc__(self):
        assert self.__no_copy, "Internal error: the code only works with non copied internal arrays"

        # numeric and symbolic UMFPACK objects are being taken care by parent class
        # self.csc_mat will be deleted with this object if it was created internally

        # common_struct and factor_strcut are taken care in parent class

{% if type in complex_list %}
        # deal with CSC matrix
        # we created rval and ival
        PyMem_Free(self.csc_rval)
        PyMem_Free(self.csc_ival)
{% else %}
        pass
{% endif %}

    ####################################################################################################################
    # CALLBACKS
    ####################################################################################################################
    def _specialized_stats(self, *args, **kwargs):
        """
        Returns a string with specialized statistics about the factorization with a :program:`CySparse` sparse matrix.
        """
        lines = []

        lines.append("CySparse matrix type: %s" % self.__A.base_type_str)
        lines.append("nrow, ncol = (%d, %d)" % (self.nrow, self.ncol) )
        lines.append("nnz = %s" % self.nnz)
        lines.append("Matrix transformation: %f secs" % self.__matrix_transform_time)

        return '\n'.join(lines)