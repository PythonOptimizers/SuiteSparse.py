from __future__ import print_function

from suitesparse.umfpack.umfpack_solver_base_@index@_@type@ cimport UmfpackSolverBase_@index@_@type@
from suitesparse.common_types.suitesparse_types cimport *
{% if type in complex_list %}
from suitesparse.common_types.suitesparse_generic_types cimport split_array_complex_values_kernel_@index@_@type@, join_array_complex_values_kernel_@index@_@type@
{% endif %}

from cysparse.sparse.s_mat cimport PySparseMatrix_Check, PyLLSparseMatrix_Check, PyCSCSparseMatrix_Check, PyCSRSparseMatrix_Check

from cpython.mem cimport PyMem_Malloc, PyMem_Realloc, PyMem_Free

cdef class UmfpackCysparseSolver_@index@_@type@(UmfpackSolverBase_@index@_@type@):
    ####################################################################################################################
    # INIT
    ####################################################################################################################
    def __cinit__(self, A, **kwargs):

        assert PySparseMatrix_Check(A), "Matrix A is not recognized as a CySparse sparse matrix"

        self.nrow = A.nrow
        self.ncol = A.ncol

        self.nnz = self.A.nnz


        if PyLLSparseMatrix_Check(self.__A):
            # transfrom matrix into CSC
            self.csc_mat = self.__A.to_csc()

        elif PyCSCSparseMatrix_Check(self.__A):
            self.csc_mat = self.__A
        elif PyCSRSparseMatrix_Check(self.__A):
            # transfrom matrix into CSC
            self.csc_mat = self.__A.to_csc()
        else:
            matrix_type = "unknown"
            try:
                matrix_type = self.__A.base_type_str
            except:
                matrix_type = type(self.__A)

            raise NotImplementedError("CySparse matrix type '%s' not recognized" % matrix_type)

        # take internal arrays
        self.ind = <@index@ *> self.csc_mat.ind

        self.row = <@index@ *> self.csc_mat.row

{% if type in complex_list %}
        # OPTIMIZATION: we could delay the creation of both arrays until
        # analyze, factorize or solve
        cdef:
            @type|cysparse_real_type_from_real_cysparse_complex_type@ * rval
            @type|cysparse_real_type_from_real_cysparse_complex_type@ * ival

        rval = <@type|cysparse_real_type_from_real_cysparse_complex_type@ *> PyMem_Malloc(self.nnz * sizeof(@type|cysparse_real_type_from_real_cysparse_complex_type@))
        if not rval:
            raise MemoryError()
        self.rval = rval

        ival = <@type|cysparse_real_type_from_real_cysparse_complex_type@ *> PyMem_Malloc(self.nnz * sizeof(@type|cysparse_real_type_from_real_cysparse_complex_type@))
        if not ival:
            PyMem_Free(rval)
            raise MemoryError()
        self.ival = ival

        split_array_complex_values_kernel_@index@_@type@(self.csc_mat.val, self.nnz,
                                                                       self.rval, self.nnz,
                                                                       self.ival, self.nnz)
{% else %}
        self.val = <@type@ *> self.csc_mat.val
{% endif %}

        # Control the matrix is fine
        self.check_matrix()

    ####################################################################################################################
    # FREE MEMORY
    ####################################################################################################################
    def __dealloc__(self):

        # numeric and symbolic UMFPACK objects are being taken care by parent class
        # self.csc_mat will be deleted with this object if it was created internally

{% if type in complex_list %}
        PyMem_Free(self.rval)
        PyMem_Free(self.ival)
{% else %}
        pass
{% endif %}

    ####################################################################################################################
    # CALLBACKS
    ####################################################################################################################
    def _specialized_stats(self, *args, **kwargs):
        """
        Returns a string with specialized statistics about the factorization with a :program:`CySparse` sparse matrix.
        """
        lines = []

        lines.append("CySparse matrix type: %s" % self.__A.base_type_str)
        lines.append("(nrow, ncol) = (%d, %d)" % (self.nrow, self.ncol) )
        lines.append("nnz = %s" % self.nnz)

        return '\n'.join(lines)